{"ast":null,"code":"import Web3 from \"web3\";\nimport { sendTransaction, callMethod } from \"./util\";\nvar web3 = new Web3(window.ethereum);\n\nconst accountStoreAbi = require(\"../../contracts-abi/AccountStore.json\");\n\nconst accountStore = new web3.eth.Contract(JSON.parse(JSON.stringify(accountStoreAbi)), process.env.REACT_APP_ACCOUNT_STORE_ADDRESS.toLowerCase());\n\nconst hashStoreAbi = require(\"../../contracts-abi/HashStore.json\");\n\nconst hashStore = new web3.eth.Contract(JSON.parse(JSON.stringify(hashStoreAbi)), process.env.REACT_APP_HASH_STORE_ADDRESS.toLowerCase()); // main methods\n\nexport const registerAccount = async (name, serverAddress) => {\n  console.log(`Registering account ${serverAddress} of ${name} on the blockchain...`);\n  const info = {\n    name: name,\n    serverAddress: serverAddress\n  };\n  const encoded = accountStore.methods.register(info).encodeABI();\n  sendTransaction(accountStore._address, encoded).then(rec => {\n    if (!rec.status) {\n      throw new Error(\"Failed to register account on the blockchain (Exists already)\");\n    }\n\n    console.log(`Account ${serverAddress} of ${name} is registered on the blockchain`);\n  });\n};\nexport const sendTranscript = async (hash, receiverAddress) => {\n  console.log(`Storing transcript hash on the blockchain...`);\n  const encoded = hashStore.methods.store(hash, receiverAddress).encodeABI();\n  return await sendTransaction(hashStore._address, encoded, async rec => {\n    if (!rec.status) {\n      throw new Error(\"Failed to send transcript\");\n    }\n\n    const log = rec.logs[0];\n    const res = web3.eth.abi.decodeParameters(['string', 'uint256'], log.data);\n    const [hash, index] = res;\n    console.log(`Hash stored. Accessible by ${receiverAddress} using index ${index}`);\n    return index;\n  });\n};\nexport const verifyTranscript = async (hash, index) => {\n  console.log(`Verifying transcript ${hash}`);\n  const encoded = hashStore.methods.validate(hash, index).encodeABI();\n  const res = await callMethod(hashStore._address, encoded);\n  return web3.eth.abi.decodeParameter('bool', res);\n}; // other methods\n\nexport const getReceivedTransactionsCount = async () => {\n  const encoded = hashStore.methods.getHashesLength().encodeABI();\n  const res = await callMethod(hashStore._address, encoded);\n  return web3.eth.abi.decodeParameter('uint256', res);\n};\nexport const getAllAccounts = async () => {\n  const encoded = accountStore.methods.getAllAccounts().encodeABI();\n  const res = await callMethod(accountStore._address, encoded);\n  return web3.eth.abi.decodeParameter('address[]', res);\n};\nexport const getAccountInfo = async address => {\n  const encoded = accountStore.methods.accountInfo(address).encodeABI();\n  const res = await callMethod(accountStore._address, encoded);\n  const r = web3.eth.abi.decodeParameters(['string', 'string'], res);\n  console.log(r);\n  return {\n    name: r[0],\n    serverAddress: r[1]\n  };\n};\nexport const checkAccountExists = async address => {\n  const encoded = accountStore.methods.accountExists(address).encodeABI();\n  const res = await callMethod(accountStore._address, encoded);\n  return web3.eth.abi.decodeParameter('bool', res);\n};","map":{"version":3,"sources":["/Users/bob/codes/mobility-blockchain-frontend/src/services/blockchain/contractCalls.js"],"names":["Web3","sendTransaction","callMethod","web3","window","ethereum","accountStoreAbi","require","accountStore","eth","Contract","JSON","parse","stringify","process","env","REACT_APP_ACCOUNT_STORE_ADDRESS","toLowerCase","hashStoreAbi","hashStore","REACT_APP_HASH_STORE_ADDRESS","registerAccount","name","serverAddress","console","log","info","encoded","methods","register","encodeABI","_address","then","rec","status","Error","sendTranscript","hash","receiverAddress","store","logs","res","abi","decodeParameters","data","index","verifyTranscript","validate","decodeParameter","getReceivedTransactionsCount","getHashesLength","getAllAccounts","getAccountInfo","address","accountInfo","r","checkAccountExists","accountExists"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,SAASC,eAAT,EAA0BC,UAA1B,QAA4C,QAA5C;AAEA,IAAIC,IAAI,GAAG,IAAIH,IAAJ,CAASI,MAAM,CAACC,QAAhB,CAAX;;AAEA,MAAMC,eAAe,GAAGC,OAAO,CAAC,uCAAD,CAA/B;;AACA,MAAMC,YAAY,GAAG,IAAIL,IAAI,CAACM,GAAL,CAASC,QAAb,CACjBC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeP,eAAf,CAAX,CADiB,EAEjBQ,OAAO,CAACC,GAAR,CAAYC,+BAAZ,CAA4CC,WAA5C,EAFiB,CAArB;;AAKA,MAAMC,YAAY,GAAGX,OAAO,CAAC,oCAAD,CAA5B;;AACA,MAAMY,SAAS,GAAG,IAAIhB,IAAI,CAACM,GAAL,CAASC,QAAb,CACdC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeK,YAAf,CAAX,CADc,EAEdJ,OAAO,CAACC,GAAR,CAAYK,4BAAZ,CAAyCH,WAAzC,EAFc,CAAlB,C,CAKA;;AAEA,OAAO,MAAMI,eAAe,GAAG,OAAOC,IAAP,EAAaC,aAAb,KAA+B;AAC1DC,EAAAA,OAAO,CAACC,GAAR,CAAa,uBAAsBF,aAAc,OAAMD,IAAK,uBAA5D;AAEA,QAAMI,IAAI,GAAG;AAAEJ,IAAAA,IAAI,EAAEA,IAAR;AAAcC,IAAAA,aAAa,EAAEA;AAA7B,GAAb;AACA,QAAMI,OAAO,GAAGnB,YAAY,CAACoB,OAAb,CAAqBC,QAArB,CAA8BH,IAA9B,EAAoCI,SAApC,EAAhB;AACA7B,EAAAA,eAAe,CAACO,YAAY,CAACuB,QAAd,EAAwBJ,OAAxB,CAAf,CAAgDK,IAAhD,CAAsDC,GAAD,IAAS;AAC1D,QAAI,CAACA,GAAG,CAACC,MAAT,EAAiB;AACb,YAAM,IAAIC,KAAJ,CAAU,+DAAV,CAAN;AACH;;AAEDX,IAAAA,OAAO,CAACC,GAAR,CAAa,WAAUF,aAAc,OAAMD,IAAK,kCAAhD;AACH,GAND;AAOH,CAZM;AAcP,OAAO,MAAMc,cAAc,GAAG,OAAOC,IAAP,EAAaC,eAAb,KAAiC;AAC3Dd,EAAAA,OAAO,CAACC,GAAR,CAAa,8CAAb;AAEA,QAAME,OAAO,GAAGR,SAAS,CAACS,OAAV,CAAkBW,KAAlB,CAAwBF,IAAxB,EAA8BC,eAA9B,EAA+CR,SAA/C,EAAhB;AACA,SAAO,MAAM7B,eAAe,CAACkB,SAAS,CAACY,QAAX,EAAqBJ,OAArB,EAA8B,MAAOM,GAAP,IAAe;AACrE,QAAI,CAACA,GAAG,CAACC,MAAT,EAAiB;AACb,YAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;AACH;;AAED,UAAMV,GAAG,GAAGQ,GAAG,CAACO,IAAJ,CAAS,CAAT,CAAZ;AACA,UAAMC,GAAG,GAAGtC,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaC,gBAAb,CAA8B,CAAC,QAAD,EAAW,SAAX,CAA9B,EAAqDlB,GAAG,CAACmB,IAAzD,CAAZ;AACA,UAAM,CAACP,IAAD,EAAOQ,KAAP,IAAgBJ,GAAtB;AACAjB,IAAAA,OAAO,CAACC,GAAR,CAAa,8BAA6Ba,eAAgB,gBAAeO,KAAM,EAA/E;AACA,WAAOA,KAAP;AACH,GAV2B,CAA5B;AAWH,CAfM;AAiBP,OAAO,MAAMC,gBAAgB,GAAG,OAAOT,IAAP,EAAaQ,KAAb,KAAuB;AACnDrB,EAAAA,OAAO,CAACC,GAAR,CAAa,wBAAuBY,IAAK,EAAzC;AACA,QAAMV,OAAO,GAAGR,SAAS,CAACS,OAAV,CAAkBmB,QAAlB,CAA2BV,IAA3B,EAAiCQ,KAAjC,EAAwCf,SAAxC,EAAhB;AACA,QAAMW,GAAG,GAAG,MAAMvC,UAAU,CAACiB,SAAS,CAACY,QAAX,EAAqBJ,OAArB,CAA5B;AACA,SAAOxB,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaM,eAAb,CAA6B,MAA7B,EAAqCP,GAArC,CAAP;AACH,CALM,C,CAQP;;AAEA,OAAO,MAAMQ,4BAA4B,GAAG,YAAY;AACpD,QAAMtB,OAAO,GAAGR,SAAS,CAACS,OAAV,CAAkBsB,eAAlB,GAAoCpB,SAApC,EAAhB;AACA,QAAMW,GAAG,GAAG,MAAMvC,UAAU,CAACiB,SAAS,CAACY,QAAX,EAAqBJ,OAArB,CAA5B;AACA,SAAOxB,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaM,eAAb,CAA6B,SAA7B,EAAwCP,GAAxC,CAAP;AACH,CAJM;AAMP,OAAO,MAAMU,cAAc,GAAG,YAAY;AACtC,QAAMxB,OAAO,GAAGnB,YAAY,CAACoB,OAAb,CAAqBuB,cAArB,GAAsCrB,SAAtC,EAAhB;AACA,QAAMW,GAAG,GAAG,MAAMvC,UAAU,CAACM,YAAY,CAACuB,QAAd,EAAwBJ,OAAxB,CAA5B;AACA,SAAOxB,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaM,eAAb,CAA6B,WAA7B,EAA0CP,GAA1C,CAAP;AACH,CAJM;AAMP,OAAO,MAAMW,cAAc,GAAG,MAAOC,OAAP,IAAmB;AAC7C,QAAM1B,OAAO,GAAGnB,YAAY,CAACoB,OAAb,CAAqB0B,WAArB,CAAiCD,OAAjC,EAA0CvB,SAA1C,EAAhB;AACA,QAAMW,GAAG,GAAG,MAAMvC,UAAU,CAACM,YAAY,CAACuB,QAAd,EAAwBJ,OAAxB,CAA5B;AACA,QAAM4B,CAAC,GAAGpD,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaC,gBAAb,CAA8B,CAAC,QAAD,EAAW,QAAX,CAA9B,EAAoDF,GAApD,CAAV;AACAjB,EAAAA,OAAO,CAACC,GAAR,CAAY8B,CAAZ;AACA,SAAO;AAACjC,IAAAA,IAAI,EAAEiC,CAAC,CAAC,CAAD,CAAR;AAAahC,IAAAA,aAAa,EAAEgC,CAAC,CAAC,CAAD;AAA7B,GAAP;AACH,CANM;AAQP,OAAO,MAAMC,kBAAkB,GAAG,MAAOH,OAAP,IAAmB;AACjD,QAAM1B,OAAO,GAAGnB,YAAY,CAACoB,OAAb,CAAqB6B,aAArB,CAAmCJ,OAAnC,EAA4CvB,SAA5C,EAAhB;AACA,QAAMW,GAAG,GAAG,MAAMvC,UAAU,CAACM,YAAY,CAACuB,QAAd,EAAwBJ,OAAxB,CAA5B;AACA,SAAOxB,IAAI,CAACM,GAAL,CAASiC,GAAT,CAAaM,eAAb,CAA6B,MAA7B,EAAqCP,GAArC,CAAP;AACH,CAJM","sourcesContent":["import Web3 from \"web3\";\nimport { sendTransaction, callMethod } from \"./util\";\n\nvar web3 = new Web3(window.ethereum);\n\nconst accountStoreAbi = require(\"../../contracts-abi/AccountStore.json\");\nconst accountStore = new web3.eth.Contract(\n    JSON.parse(JSON.stringify(accountStoreAbi)),\n    process.env.REACT_APP_ACCOUNT_STORE_ADDRESS.toLowerCase()\n);\n\nconst hashStoreAbi = require(\"../../contracts-abi/HashStore.json\");\nconst hashStore = new web3.eth.Contract(\n    JSON.parse(JSON.stringify(hashStoreAbi)),\n    process.env.REACT_APP_HASH_STORE_ADDRESS.toLowerCase()\n);\n\n// main methods\n\nexport const registerAccount = async (name, serverAddress) => {\n    console.log(`Registering account ${serverAddress} of ${name} on the blockchain...`);\n\n    const info = { name: name, serverAddress: serverAddress };\n    const encoded = accountStore.methods.register(info).encodeABI();\n    sendTransaction(accountStore._address, encoded).then((rec) => {\n        if (!rec.status) {\n            throw new Error(\"Failed to register account on the blockchain (Exists already)\");\n        }\n\n        console.log(`Account ${serverAddress} of ${name} is registered on the blockchain`);\n    });\n};\n\nexport const sendTranscript = async (hash, receiverAddress) => {\n    console.log(`Storing transcript hash on the blockchain...`);\n\n    const encoded = hashStore.methods.store(hash, receiverAddress).encodeABI();\n    return await sendTransaction(hashStore._address, encoded, async (rec) => {\n        if (!rec.status) {\n            throw new Error(\"Failed to send transcript\");\n        }\n\n        const log = rec.logs[0];\n        const res = web3.eth.abi.decodeParameters(['string', 'uint256'], log.data);\n        const [hash, index] = res;\n        console.log(`Hash stored. Accessible by ${receiverAddress} using index ${index}`);\n        return index;\n    });\n};\n\nexport const verifyTranscript = async (hash, index) => {\n    console.log(`Verifying transcript ${hash}`);\n    const encoded = hashStore.methods.validate(hash, index).encodeABI();\n    const res = await callMethod(hashStore._address, encoded);\n    return web3.eth.abi.decodeParameter('bool', res);\n};\n\n\n// other methods\n\nexport const getReceivedTransactionsCount = async () => {\n    const encoded = hashStore.methods.getHashesLength().encodeABI();\n    const res = await callMethod(hashStore._address, encoded);\n    return web3.eth.abi.decodeParameter('uint256', res);\n};\n\nexport const getAllAccounts = async () => {\n    const encoded = accountStore.methods.getAllAccounts().encodeABI();\n    const res = await callMethod(accountStore._address, encoded);\n    return web3.eth.abi.decodeParameter('address[]', res);\n}\n\nexport const getAccountInfo = async (address) => {\n    const encoded = accountStore.methods.accountInfo(address).encodeABI();\n    const res = await callMethod(accountStore._address, encoded);\n    const r = web3.eth.abi.decodeParameters(['string', 'string'], res);\n    console.log(r)\n    return {name: r[0], serverAddress: r[1]};\n}\n\nexport const checkAccountExists = async (address) => {\n    const encoded = accountStore.methods.accountExists(address).encodeABI();\n    const res = await callMethod(accountStore._address, encoded);\n    return web3.eth.abi.decodeParameter('bool', res);\n};\n"]},"metadata":{},"sourceType":"module"}