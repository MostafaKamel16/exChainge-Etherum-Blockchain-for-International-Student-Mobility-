{"ast":null,"code":"import { readPartnerUni, userLogin, registerUser, updatePartnerUnis } from \"../../services/api\";\nimport { authenticate } from \"../../auth/auth\";\nimport { getAllAccounts, getAccountInfo } from \"../../services/blockchain/contractCalls\";\nexport function signup(username, publicAddress, serverAddress) {\n  function onSuccess(user) {\n    console.log(\"Success\" + user);\n    return {\n      type: \"SIGNUP_SUCCESS\",\n      user\n    };\n  }\n\n  function onFailure(error) {\n    return {\n      type: \"SIGNUP_FAILURE\",\n      error\n    };\n  }\n\n  function onUserAlreadyExists(error) {\n    return {\n      type: \"SIGNUP_USER_EXISTS\",\n      error\n    };\n  }\n\n  return async dispatch => {\n    try {\n      //const user = await readUser(publicAddress);\n      // if (username !== user.username) {\n      const data = await registerUser(publicAddress, username, serverAddress);\n\n      if (data) {\n        updatePartnerUniList(data.token);\n        dispatch(onSuccess({\n          username: data.username,\n          metamask_address: data.metamask_address\n        }));\n        authenticate(data);\n      } else dispatch(onUserAlreadyExists(\"User resgistered already\"));\n    } catch (e) {\n      if (e === 401) {\n        dispatch(onFailure(e));\n      } else {\n        dispatch(onUserAlreadyExists(e));\n      }\n    }\n  };\n}\nexport function login(username, signData) {\n  function onSuccess(user) {\n    console.log(\"Success\" + user);\n    return {\n      type: \"LOGIN_SUCCESS\",\n      user\n    };\n  }\n\n  function onFailure(error) {\n    return {\n      type: \"LOGIN_FAILURE\",\n      error\n    };\n  }\n\n  function onUserNotFound(error) {\n    return {\n      type: \"LOGIN_USER_NOT_FOUND\",\n      error\n    };\n  }\n\n  return async dispatch => {\n    try {\n      const data = await userLogin(signData.publicAddress, signData.signature);\n      const {\n        user\n      } = data;\n      const resp = user.metamask_address.toLowerCase() === signData.publicAddress.toLowerCase();\n\n      if (resp) {\n        updatePartnerUniList(data.token);\n        dispatch(onSuccess({\n          username: user.username,\n          metamask_address: user.metamask_address\n        }));\n        authenticate(data);\n      } else dispatch(onUserNotFound(\"User not present\"));\n    } catch (e) {\n      if (e === 401) {\n        dispatch(onFailure(e));\n      } else {\n        dispatch(onUserNotFound(e));\n      }\n    }\n  };\n}\n\nconst updatePartnerUniList = async token => {\n  const blockchainList = await getAllAccounts();\n  const storedUnis = await readPartnerUni(token);\n  console.log('stored accs', storedUnis);\n  var userList = [];\n\n  for (var i = storedUnis.length; i !== blockchainList.length; ++i) {\n    const blockchainAddress = blockchainList[i];\n    const res = await getAccountInfo(blockchainAddress);\n    userList.push({\n      partner_university: res.name,\n      server_address: res.serverAddress,\n      blockchain_address: blockchainAddress\n    });\n  }\n\n  console.log('new accs', userList);\n  const res = await updatePartnerUnis(userList, token);\n  console.log('all accs', res);\n  await localStorage.setItem('partnerUnis', JSON.stringify(res));\n};","map":{"version":3,"sources":["/Users/bob/codes/mobility-blockchain-frontend/src/redux/action/userAction.js"],"names":["readPartnerUni","userLogin","registerUser","updatePartnerUnis","authenticate","getAllAccounts","getAccountInfo","signup","username","publicAddress","serverAddress","onSuccess","user","console","log","type","onFailure","error","onUserAlreadyExists","dispatch","data","updatePartnerUniList","token","metamask_address","e","login","signData","onUserNotFound","signature","resp","toLowerCase","blockchainList","storedUnis","userList","i","length","blockchainAddress","res","push","partner_university","name","server_address","blockchain_address","localStorage","setItem","JSON","stringify"],"mappings":"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","sourcesContent":["import { readPartnerUni, userLogin, registerUser, updatePartnerUnis } from \"../../services/api\";\nimport { authenticate } from \"../../auth/auth\";\nimport { getAllAccounts, getAccountInfo } from \"../../services/blockchain/contractCalls\";\n\nexport function signup(username, publicAddress, serverAddress) {\n    function onSuccess(user) {\n        console.log(\"Success\" + user);\n        return { type: \"SIGNUP_SUCCESS\", user };\n    }\n\n    function onFailure(error) {\n        return { type: \"SIGNUP_FAILURE\", error };\n    }\n\n    function onUserAlreadyExists(error) {\n        return { type: \"SIGNUP_USER_EXISTS\", error };\n    }\n\n    return async (dispatch) => {\n        try {\n            //const user = await readUser(publicAddress);\n            // if (username !== user.username) {\n            const data = await registerUser(publicAddress, username, serverAddress);\n            if (data) {\n                updatePartnerUniList(data.token);\n                dispatch(onSuccess({ username: data.username, metamask_address: data.metamask_address }));\n                authenticate(data);\n            } else dispatch(onUserAlreadyExists(\"User resgistered already\"));\n        } catch (e) {\n            if (e === 401) {\n                dispatch(onFailure(e));\n            } else {\n                dispatch(onUserAlreadyExists(e));\n            }\n        }\n    };\n}\n\nexport function login(username, signData) {\n    function onSuccess(user) {\n        console.log(\"Success\" + user);\n        return { type: \"LOGIN_SUCCESS\", user };\n    }\n\n    function onFailure(error) {\n        return { type: \"LOGIN_FAILURE\", error };\n    }\n\n    function onUserNotFound(error) {\n        return { type: \"LOGIN_USER_NOT_FOUND\", error };\n    }\n\n    return async (dispatch) => {\n        try {\n            const data = await userLogin(\n                signData.publicAddress,\n                signData.signature\n            );\n            const { user } = data;\n            const resp = user.metamask_address.toLowerCase() === signData.publicAddress.toLowerCase();\n            if (resp) {\n                updatePartnerUniList(data.token);\n                dispatch(onSuccess({ username: user.username, metamask_address: user.metamask_address }));\n                authenticate(data);\n            }\n            else dispatch(onUserNotFound(\"User not present\"));\n        } catch (e) {\n            if (e === 401) {\n                dispatch(onFailure(e));\n            } else {\n                dispatch(onUserNotFound(e));\n            }\n        }\n    };\n}\n\nconst updatePartnerUniList = async (token) => {\n    const blockchainList = await getAllAccounts();\n    const storedUnis = await readPartnerUni(token);\n    console.log('stored accs', storedUnis);\n\n    var userList = [];\n    for (var i = storedUnis.length; i !== blockchainList.length; ++i) {\n        const blockchainAddress = blockchainList[i];\n        const res = await getAccountInfo(blockchainAddress);\n        userList.push({ partner_university: res.name, server_address: res.serverAddress, blockchain_address: blockchainAddress });\n    }\n\n    console.log('new accs', userList);\n    const res = await updatePartnerUnis(userList, token);\n    console.log('all accs', res);\n    await localStorage.setItem('partnerUnis', JSON.stringify(res));\n}\n"]},"metadata":{},"sourceType":"module"}