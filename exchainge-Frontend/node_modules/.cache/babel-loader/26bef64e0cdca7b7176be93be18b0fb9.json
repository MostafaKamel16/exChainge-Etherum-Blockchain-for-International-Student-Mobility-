{"ast":null,"code":"import Web3 from \"web3\";\nvar wl = window.ethereum;\nvar web3;\nvar account; // should be called the first time Metamask is needed\n\nexport const startService = async () => {\n  if (!wl) {\n    window.alert(\"Please install MetaMask first.\");\n    return;\n  }\n\n  if (!web3) {\n    try {\n      // Request account access if needed\n      await wl.enable(); // We don't know window.web3 version, so we use our own instance of Web3\n      // with the injected provider given by MetaMask\n\n      web3 = new Web3(wl);\n    } catch (error) {\n      window.alert(\"You need to allow MetaMask.\");\n      return;\n    }\n  }\n\n  const coinbase = await web3.eth.getCoinbase();\n\n  if (!coinbase) {\n    window.alert(\"Please activate MetaMask first.\");\n    return;\n  } // set account to the account currently connected\n\n\n  account = (await web3.eth.getAccounts())[0];\n};\nexport const getCurrentAccount = () => {\n  return account;\n};\nexport const getBalance = async () => {\n  return await web3.eth.getBalance(account);\n};\nexport const signNonce = async nonce => {\n  return await web3.eth.personal.sign(`I am signing my one-time nonce: ${nonce}`, getCurrentAccount(), \"\" // MetaMask will ignore the password argument here\n  );\n};\nexport const sendTransaction = async (contractAddress, encodedData) => {\n  const txHash = await ethRequest('eth_sendTransaction', contractAddress, encodedData);\n  console.log('Transaction hash', txHash);\n  return await getTransactionReceipt(txHash);\n};\nexport const getTransactionReceipt = hash => {\n  return new Promise((resolve, reject) => {\n    const interval = setInterval(async () => {\n      console.log(\"Attempting to get transaction receipt...\");\n      const rec = await web3.eth.getTransactionReceipt(hash);\n\n      if (rec) {\n        console.log('found receipt');\n        clearInterval(interval);\n        resolve(rec);\n      }\n    }, 1000);\n  });\n};\nexport const callMethod = async (contractAddress, encodedData) => {\n  return await ethRequest('eth_call', contractAddress, encodedData);\n};\nexport const ethRequest = (method, toAddress, data) => {\n  const account = getCurrentAccount();\n  return wl.request({\n    method: method,\n    params: [{\n      from: account,\n      to: toAddress,\n      data: data\n    }]\n  });\n};\nexport const minWeiBalance = 0x5AF3107A4000; // 0.0001eth\n\nexport const weiFundString = \"0x2386F26FC10000\"; // 0.01eth (enough for ~1000 transactions)","map":{"version":3,"sources":["/Users/bob/codes/mobility-blockchain-frontend/src/services/blockchain/util.js"],"names":["Web3","wl","window","ethereum","web3","account","startService","alert","enable","error","coinbase","eth","getCoinbase","getAccounts","getCurrentAccount","getBalance","signNonce","nonce","personal","sign","sendTransaction","contractAddress","encodedData","txHash","ethRequest","console","log","getTransactionReceipt","hash","Promise","resolve","reject","interval","setInterval","rec","clearInterval","callMethod","method","toAddress","data","request","params","from","to","minWeiBalance","weiFundString"],"mappings":"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","sourcesContent":["import Web3 from \"web3\";\n\nvar wl = window.ethereum;\nvar web3;\nvar account;\n\n// should be called the first time Metamask is needed\nexport const startService = async () => {\n    if (!wl) {\n        window.alert(\"Please install MetaMask first.\");\n        return;\n    }\n    if (!web3) {\n        try {\n            // Request account access if needed\n            await wl.enable();\n\n            // We don't know window.web3 version, so we use our own instance of Web3\n            // with the injected provider given by MetaMask\n            web3 = new Web3(wl);\n        } catch (error) {\n            window.alert(\"You need to allow MetaMask.\");\n            return;\n        }\n    }\n    const coinbase = await web3.eth.getCoinbase();\n    if (!coinbase) {\n        window.alert(\"Please activate MetaMask first.\");\n        return;\n    }\n\n    // set account to the account currently connected\n    account = (await web3.eth.getAccounts())[0];\n};\n\nexport const getCurrentAccount = () => {\n    return account;\n};\n\nexport const getBalance = async () => {\n    return await web3.eth.getBalance(account);\n}\n\nexport const signNonce = async (nonce) => {\n    return await web3.eth.personal.sign(\n        `I am signing my one-time nonce: ${nonce}`,\n        getCurrentAccount(),\n        \"\" // MetaMask will ignore the password argument here\n    );\n};\n\nexport const sendTransaction = async (contractAddress, encodedData) => {\n    const txHash = await ethRequest('eth_sendTransaction', contractAddress, encodedData);\n    console.log('Transaction hash', txHash);\n    return await getTransactionReceipt(txHash);\n};\n\nexport const getTransactionReceipt = (hash) => {\n    return new Promise((resolve, reject) => {\n        const interval = setInterval(async () => {\n            console.log(\"Attempting to get transaction receipt...\");\n            const rec = await web3.eth.getTransactionReceipt(hash);\n            if (rec) {\n                console.log('found receipt');\n                clearInterval(interval);\n                resolve(rec);\n            }\n        }, 1000);\n    });\n};\n\nexport const callMethod = async (contractAddress, encodedData) => {\n    return await ethRequest('eth_call', contractAddress, encodedData);\n};\n\nexport const ethRequest = (method, toAddress, data) => {\n    const account = getCurrentAccount();\n    return wl.request({\n        method: method,\n        params: [\n            {\n                from: account,\n                to: toAddress,\n                data: data,\n            }\n        ]\n    });\n};\n\nexport const minWeiBalance = 0x5AF3107A4000; // 0.0001eth\nexport const weiFundString = \"0x2386F26FC10000\"; // 0.01eth (enough for ~1000 transactions)\n"]},"metadata":{},"sourceType":"module"}