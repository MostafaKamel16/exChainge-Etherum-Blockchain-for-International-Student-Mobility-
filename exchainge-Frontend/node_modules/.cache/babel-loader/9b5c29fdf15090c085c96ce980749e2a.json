{"ast":null,"code":"import { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nconst BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nconst BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nconst getBatchFromState = (state, id) => state.batches[id].batch;\n\nconst getBatch = (queue, id) => {\n  return getBatchFromState(queue.getState(), id);\n};\n\nconst isItemBelongsToBatch = (queue, itemId, batchId) => {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nconst getBatchDataFromItemId = (queue, itemId) => {\n  const state = queue.getState();\n  const item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nconst getBatchFromItemId = (queue, itemId) => {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nconst removeBatchItems = (queue, batchId) => {\n  const batch = getBatch(queue, batchId);\n  queue.updateState(state => {\n    batch.items.forEach(_ref => {\n      let {\n        id\n      } = _ref;\n      delete state.items[id];\n      const index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nconst removeBatch = (queue, batchId) => {\n  queue.updateState(state => {\n    delete state.batches[batchId];\n  });\n};\n\nconst cancelBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId),\n        batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch\n  });\n  queue.updateState(state => {\n    const batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nconst isNewBatchStarting = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nconst loadNewBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(isCancelled => {\n    if (!isCancelled) {\n      queue.updateState(state => {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nconst cleanUpFinishedBatches = queue => {\n  //TODO: schedule clean up on requestAnimationFrame\n  const state = queue.getState();\n  Object.keys(state.batches).forEach(batchId => {\n    const {\n      batch,\n      finishedCounter\n    } = state.batches[batchId];\n    const {\n      orgItemCount\n    } = batch; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    const alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      //batch may not be updated with completed/loaded with 100% values\n      if (!alreadyFinalized && batch.completed !== 100) {\n        queue.updateState(state => {\n          const batch = getBatchFromState(state, batchId);\n          batch.completed = 100;\n          batch.loaded = batch.items.reduce((res, _ref2) => {\n            let {\n              loaded\n            } = _ref2;\n            return res + loaded;\n          }, 0);\n        }); //ensure we trigger progress event with completed = 100 for all items\n\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_PROGRESS);\n      }\n\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nconst triggerUploaderBatchEvent = (queue, batchId, event) => {\n  const state = queue.getState(),\n        batch = getBatchFromState(state, batchId),\n        //get the most uptodate batch data\n  stateItems = state.items;\n  const eventBatch = { ...unwrap(batch),\n    items: batch.items.map(_ref3 => {\n      let {\n        id\n      } = _ref3;\n      return unwrap(stateItems[id]);\n    })\n  };\n  queue.trigger(event, eventBatch);\n};\n\nconst getIsItemBatchReady = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nconst detachRecycledFromPreviousBatch = (queue, item) => {\n  const {\n    previousBatch\n  } = item;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    const {\n      id: batchId\n    } = getBatchFromItemId(queue, item.id);\n\n    if (batchId === previousBatch) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId);\n        const index = batch.items.findIndex(_ref4 => {\n          let {\n            id\n          } = _ref4;\n          return id === item.id;\n        });\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nconst preparePendingForUpload = (queue, uploadOptions) => {\n  queue.updateState(state => {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(batchId => {\n      const batchData = state.batches[batchId];\n      const {\n        batch,\n        batchOptions\n      } = batchData;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(item => {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nconst removePendingBatches = queue => {\n  const batches = queue.getState().batches;\n  Object.keys(batches).filter(batchId => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach(batchId => {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nconst incrementBatchFinishedCounter = (queue, batchId) => {\n  queue.updateState(state => {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nconst getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };","map":{"version":3,"sources":["/Users/bob/codes/mobility-blockchain-frontend/node_modules/@rpldy/uploader/lib/esm/queue/batchHelpers.js"],"names":["BATCH_STATES","logger","merge","FILE_STATES","unwrap","UPLOADER_EVENTS","BATCH_READY_STATES","ADDED","PROCESSING","UPLOADING","BATCH_FINISHED_STATES","ABORTED","CANCELLED","FINISHED","getBatchFromState","state","id","batches","batch","getBatch","queue","getState","isItemBelongsToBatch","itemId","batchId","items","getBatchDataFromItemId","item","getBatchFromItemId","removeBatchItems","updateState","forEach","index","itemQueue","indexOf","splice","removeBatch","cancelBatchForItem","debugLog","triggerUploaderBatchEvent","BATCH_CANCEL","isNewBatchStarting","currentBatch","loadNewBatchForItem","runCancellable","BATCH_START","then","isCancelled","cleanUpFinishedBatches","Object","keys","finishedCounter","orgItemCount","alreadyFinalized","getIsBatchFinalized","completed","loaded","reduce","res","BATCH_PROGRESS","BATCH_FINISH","event","stateItems","eventBatch","map","trigger","getIsItemBatchReady","includes","detachRecycledFromPreviousBatch","previousBatch","recycled","findIndex","preparePendingForUpload","uploadOptions","batchData","batchOptions","PENDING","removePendingBatches","filter","incrementBatchFinishedCounter"],"mappings":"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","sourcesContent":["import { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nconst BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nconst BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nconst getBatchFromState = (state, id) => state.batches[id].batch;\n\nconst getBatch = (queue, id) => {\n  return getBatchFromState(queue.getState(), id);\n};\n\nconst isItemBelongsToBatch = (queue, itemId, batchId) => {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nconst getBatchDataFromItemId = (queue, itemId) => {\n  const state = queue.getState();\n  const item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nconst getBatchFromItemId = (queue, itemId) => {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nconst removeBatchItems = (queue, batchId) => {\n  const batch = getBatch(queue, batchId);\n  queue.updateState(state => {\n    batch.items.forEach(({\n      id\n    }) => {\n      delete state.items[id];\n      const index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nconst removeBatch = (queue, batchId) => {\n  queue.updateState(state => {\n    delete state.batches[batchId];\n  });\n};\n\nconst cancelBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId),\n        batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch\n  });\n  queue.updateState(state => {\n    const batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nconst isNewBatchStarting = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nconst loadNewBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(isCancelled => {\n    if (!isCancelled) {\n      queue.updateState(state => {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nconst cleanUpFinishedBatches = queue => {\n  //TODO: schedule clean up on requestAnimationFrame\n  const state = queue.getState();\n  Object.keys(state.batches).forEach(batchId => {\n    const {\n      batch,\n      finishedCounter\n    } = state.batches[batchId];\n    const {\n      orgItemCount\n    } = batch; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    const alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      //batch may not be updated with completed/loaded with 100% values\n      if (!alreadyFinalized && batch.completed !== 100) {\n        queue.updateState(state => {\n          const batch = getBatchFromState(state, batchId);\n          batch.completed = 100;\n          batch.loaded = batch.items.reduce((res, {\n            loaded\n          }) => res + loaded, 0);\n        }); //ensure we trigger progress event with completed = 100 for all items\n\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_PROGRESS);\n      }\n\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nconst triggerUploaderBatchEvent = (queue, batchId, event) => {\n  const state = queue.getState(),\n        batch = getBatchFromState(state, batchId),\n        //get the most uptodate batch data\n  stateItems = state.items;\n  const eventBatch = { ...unwrap(batch),\n    items: batch.items.map(({\n      id\n    }) => unwrap(stateItems[id]))\n  };\n  queue.trigger(event, eventBatch);\n};\n\nconst getIsItemBatchReady = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nconst detachRecycledFromPreviousBatch = (queue, item) => {\n  const {\n    previousBatch\n  } = item;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    const {\n      id: batchId\n    } = getBatchFromItemId(queue, item.id);\n\n    if (batchId === previousBatch) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId);\n        const index = batch.items.findIndex(({\n          id\n        }) => id === item.id);\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nconst preparePendingForUpload = (queue, uploadOptions) => {\n  queue.updateState(state => {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(batchId => {\n      const batchData = state.batches[batchId];\n      const {\n        batch,\n        batchOptions\n      } = batchData;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(item => {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nconst removePendingBatches = queue => {\n  const batches = queue.getState().batches;\n  Object.keys(batches).filter(batchId => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach(batchId => {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nconst incrementBatchFinishedCounter = (queue, batchId) => {\n  queue.updateState(state => {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nconst getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };"]},"metadata":{},"sourceType":"module"}